=encoding utf8

=head1 Keypto

=head2 road_map

C<key_ing()> (ran$omware)

C<key_cut()>, C<key_tip()>, C<key_bow()>, C<sho_ldr()> (L<anatomy|https://en.wikipedia.org/wiki/Key_(lock)>)

C<key_off()> (to take as a controlling input datum; this logic keys off the users social security number...is that a bitmask?)

C<key_pad()> (keyboard, for typing; non-instructional typing)

C<key_pal()> (penpal via email)

C<key_set()> (instruction-set, but could just be a set of keys)

C<key_way()> (keyhole)

=head4 key_ces()

reverse engineer C<key_sec()>

=head4 key_sec()

deadlocked with other commitments versus licensing; in the mean time explore other tech...probably steganography

=head4 key_xch()

need to figure out how I want to change passwords... f(old.key, new.key) = buffer.buf

password fields: old.key=p0, new.key=p1

C<key_xch($old_file, $new_file)>

C<¿¿¿TIME TO RESET???> -> C<¡¡¡TIME TO RESET!!!>

=head3 key_gen()

C<key_gen($file)> where C<$file> is in a L<CSV|https://en.wikipedia.org/wiki/Comma-separated_values> format

B<input demo:> C<./mold.csv>

B<output demo:> C<./old.key> C<./new.key>

B<CSV format:>

first line is (custom) header; soft-coding means "free software" (but more effort)

field headers are case-insensitively alphabetic (collision-prone)

primary field: C<:csv_field> (EG C<:address>)

required field: C<key_field:min> (EG C<p:min>, p for password; what this field is for)

optional field: C<max>

special optional field: C<charray> (the only multi-valued field)

B<...need to change!!! to make this "free" software...>

=head4 CSV format (input)

	$message
	@headers
	@formats
	@record_1
	@record_2
	@record_3
	...
	@record_n

B<C<$message>:>

=over

=item * optional; no C<,> characters, otherwise it will be treated as the C<@headers> line

=item * this is spliced between everything

=back

B<C<@headers>:>

=over

=item * the order of fields determines the order of text generation

=item * there are no mandatory fields; for freedom!!! :D

=item * B<header format 0:> C<$shared_field>

=item * B<header format 1:> C<$key_field:$csv_field>, where C<$key_field> is used in the key file, and C<$csv_field> is used descriptively (self-documenting source)

=back

B<C<@formats>:>

=over

=item * if quantity is less than headers, final format will be used for the rest

=item * B<escape character:> C<\>

=item * B<escapable sequences:> C<\>, C<,>, C< > (space; spaces are trimmed)

=item * I<cure for the one true syntax syndrome (this should be in the Ethics module?)>

=back

B<example:>

	\n\nTIME TO RESET\n
	place, p:key, u:user, e:email, n:name, a:address, phone,..
	\n%s, \n\t%S: %s
	github.com, 7-72((1..3),('a'..'b')),..
	abc.com, 8,..
	xyz.com, 8,..

=head4 KEY format (output)

	Generated by Keypto at $timestamp$message$record_1$message$record_2$message$record_3$message...$message$record_n$message

=head2 key_rng()

C<key_rng($min, $max=$min, @char=(...))> returns a random string

C<@char> is all-case alphanumerical by default

