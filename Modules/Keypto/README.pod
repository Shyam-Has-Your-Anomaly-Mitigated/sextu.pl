=encoding utf8

=head1 Keypto

=head3 road_map

=head4 key_sec()

deadlocked with other commitments versus licensing; in the mean time explore other tech...probably steganography

=head4 key_chk()

goto L<scripting|https://www.open.edu.au/courses/it/rmit-university-scripting-language-programming--cpt223-2017> assignments; checksum injection...this time, gotta crack 'ém all! :D

=head4 key_xch()

need to figure out how I want to change passwords... f(old.key, new.key) = buffer.buf

password fields: old.key=p0, new.key=p1

C<key_xch($old_file, $new_file)>

C<¿¿¿TIME TO RESET???> -> C<¡¡¡TIME TO RESET!!!>

=head3 key_gen()

C<key_gen($file)> where C<$file> is in a L<CSV|https://en.wikipedia.org/wiki/Comma-separated_values> format

B<input demo:> C<./mold.csv>

B<output demo:> C<./old.key> C<./new.key>

B<CSV format:>

first line is (custom) header; soft-coding means "free software" (but more effort)

field headers are case-insensitively alphabetic (collision-prone)

primary field: C<:csv_field> (EG C<:address>)

required field: C<key_field:min> (EG C<p:min>)

optional field: C<max>

special optional field: C<charray> (the only multi-valued field)

creative fields: C<key_field:csv_field> (EG C<p:phone>, C<u:user>, C<e:email>)

I<for "creative fields", C<csv_field> will use the first char for C<key_field>; as demonstrated>

=head3 key_rng()

C<key_rng($min, $max=$min, @char=(...))> returns a random string

C<@char> is all-case alphanumerical by default

