=encoding utf8

=head1 Keypto

=head3 road_map

C<key_ing()> (ran$omware)

C<key_cut()>, C<key_tip()>, C<key_bow()>, C<sho_ldr()> (L<anatomy|https://en.wikipedia.org/wiki/Key_(lock)>)

C<key_off()> (to take as a controlling input datum; this logic keys off the users social security number...is that a bitmask?)

C<key_pad()> (keyboard, for typing; non-instructional typing)

C<key_pal()> (penpal via email)

C<key_set()> (instruction-set, but could just be a set of keys)

C<key_way()> (keyhole)

=head4 key_ces()

reverse engineer C<key_sec()>

=head4 key_sec()

deadlocked with other commitments versus licensing; in the mean time explore other tech...probably steganography

=head4 key_xch()

need to figure out how I want to change passwords... f(old.key, new.key) = buffer.buf

password fields: old.key=p0, new.key=p1

C<key_xch($old_file, $new_file)>

C<¿¿¿TIME TO RESET???> -> C<¡¡¡TIME TO RESET!!!>

=head3 key_gen()

C<key_gen($file)> where C<$file> is in a L<CSV|https://en.wikipedia.org/wiki/Comma-separated_values> format

B<input demo:> C<./mold.csv>

B<output demo:> C<./old.key> C<./new.key>

B<CSV format:>

first line is (custom) header; soft-coding means "free software" (but more effort)

field headers are case-insensitively alphabetic (collision-prone)

primary field: C<:csv_field> (EG C<:address>)

required field: C<key_field:min> (EG C<p:min>)

optional field: C<max>

special optional field: C<charray> (the only multi-valued field)

creative fields: C<key_field:csv_field> (EG C<p:phone>, C<u:user>, C<e:email>)

I<for "creative fields", C<csv_field> will use the first char for C<key_field>; as demonstrated>

=head3 key_rng()

C<key_rng($min, $max=$min, @char=(...))> returns a random string

C<@char> is all-case alphanumerical by default

